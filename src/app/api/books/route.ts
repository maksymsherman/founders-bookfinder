import { NextRequest, NextResponse } from 'next/server';
import { BookDatabase, convertDatabaseBookToBook } from '@/lib/database-utils';
import { isSupabaseConfigured } from '@/lib/supabase';
import { ApiError, BooksResponse } from '@/types';

export async function GET(request: NextRequest) {
  try {
    // Check if Supabase is configured
    if (!isSupabaseConfigured()) {
      const error: ApiError = {
        message: 'Database is not configured. Please set Supabase environment variables.',
        code: 'DATABASE_NOT_CONFIGURED',
      };
      return NextResponse.json(error, { status: 503 });
    }

    const url = new URL(request.url);
    const page = parseInt(url.searchParams.get('page') || '1');
    const limit = parseInt(url.searchParams.get('limit') || '50');
    const search = url.searchParams.get('search');
    const status = url.searchParams.get('status') as 'pending' | 'enhanced' | 'failed' | 'not_found' | null;
    const episodeId = url.searchParams.get('episodeId');

    // Validate pagination parameters
    if (page < 1 || limit < 1 || limit > 100) {
      const error: ApiError = {
        message: 'Invalid pagination parameters. Page must be >= 1, limit must be 1-100.',
        code: 'INVALID_PAGINATION',
      };
      return NextResponse.json(error, { status: 400 });
    }

    const offset = (page - 1) * limit;
    let books;

    // Handle different query types
    if (search) {
      books = await BookDatabase.searchBooks(search, limit);
    } else if (status) {
      books = await BookDatabase.getBooksByEnhancementStatus(status);
    } else if (episodeId) {
      books = await BookDatabase.getBooksByEpisodeId(episodeId);
    } else {
      books = await BookDatabase.getAllBooks(limit, offset);
    }

    // Convert database books to application books
    const convertedBooks = books.map(convertDatabaseBookToBook);

    const response: BooksResponse = {
      books: convertedBooks,
      lastUpdated: new Date().toISOString(),
      totalCount: convertedBooks.length,
      page,
      totalPages: Math.ceil(convertedBooks.length / limit),
    };

    return NextResponse.json(response);

  } catch (error) {
    console.error('Error fetching books:', error);
    
    const apiError: ApiError = {
      message: 'Internal server error while fetching books',
      code: 'INTERNAL_SERVER_ERROR',
      details: error instanceof Error ? error.message : 'Unknown error',
    };
    
    return NextResponse.json(apiError, { status: 500 });
  }
}

export async function POST(request: NextRequest) {
  try {
    // Check if Supabase is configured
    if (!isSupabaseConfigured()) {
      const error: ApiError = {
        message: 'Database is not configured. Please set Supabase environment variables.',
        code: 'DATABASE_NOT_CONFIGURED',
      };
      return NextResponse.json(error, { status: 503 });
    }

    const body = await request.json();
    
    // Validate request body
    if (!body.title || !body.author || !body.episodeTitle || !body.episodeDate) {
      const error: ApiError = {
        message: 'Missing required fields: title, author, episodeTitle, episodeDate',
        code: 'INVALID_REQUEST',
      };
      return NextResponse.json(error, { status: 400 });
    }

    // Create book object
    const book = {
      id: '', // Will be generated by database
      title: body.title,
      author: body.author,
      episodeId: body.episodeId || '',
      episodeTitle: body.episodeTitle,
      episodeDate: body.episodeDate,
      extractedLinks: body.extractedLinks || [],
      context: body.context,
      isbn: body.isbn,
      isbn13: body.isbn13,
      isbn10: body.isbn10,
      publisher: body.publisher,
      publishedDate: body.publishedDate,
      description: body.description,
      pageCount: body.pageCount,
      categories: body.categories,
      averageRating: body.averageRating,
      ratingsCount: body.ratingsCount,
      language: body.language,
      infoLink: body.infoLink,
      coverImage: body.coverImage,
      dateAdded: new Date().toISOString(),
    };

    // Insert book into database
    const dbBook = await BookDatabase.insertBook(book);
    
    if (!dbBook) {
      const error: ApiError = {
        message: 'Failed to create book',
        code: 'BOOK_CREATION_FAILED',
      };
      return NextResponse.json(error, { status: 500 });
    }

    // Convert and return created book
    const createdBook = convertDatabaseBookToBook(dbBook);
    
    return NextResponse.json(createdBook, { status: 201 });

  } catch (error) {
    console.error('Error creating book:', error);
    
    const apiError: ApiError = {
      message: 'Internal server error while creating book',
      code: 'INTERNAL_SERVER_ERROR',
      details: error instanceof Error ? error.message : 'Unknown error',
    };
    
    return NextResponse.json(apiError, { status: 500 });
  }
}

export async function PUT(request: NextRequest) {
  try {
    // Check if Supabase is configured
    if (!isSupabaseConfigured()) {
      const error: ApiError = {
        message: 'Database is not configured. Please set Supabase environment variables.',
        code: 'DATABASE_NOT_CONFIGURED',
      };
      return NextResponse.json(error, { status: 503 });
    }

    const body = await request.json();
    
    // Validate request body
    if (!body.id) {
      const error: ApiError = {
        message: 'Missing required field: id',
        code: 'INVALID_REQUEST',
      };
      return NextResponse.json(error, { status: 400 });
    }

    // Check if book exists
    const existingBook = await BookDatabase.getBookById(body.id);
    if (!existingBook) {
      const error: ApiError = {
        message: 'Book not found',
        code: 'BOOK_NOT_FOUND',
      };
      return NextResponse.json(error, { status: 404 });
    }

    // Prepare update data (only include fields that are provided)
    const updateData: any = {};
    
    if (body.title) updateData.title = body.title;
    if (body.author) updateData.author = body.author;
    if (body.episodeId) updateData.episode_id = body.episodeId;
    if (body.episodeTitle) updateData.episode_title = body.episodeTitle;
    if (body.episodeDate) updateData.episode_date = body.episodeDate;
    if (body.extractedLinks) updateData.extracted_links = body.extractedLinks;
    if (body.context !== undefined) updateData.context = body.context;
    if (body.isbn !== undefined) updateData.isbn = body.isbn;
    if (body.isbn13 !== undefined) updateData.isbn13 = body.isbn13;
    if (body.isbn10 !== undefined) updateData.isbn10 = body.isbn10;
    if (body.publisher !== undefined) updateData.publisher = body.publisher;
    if (body.publishedDate !== undefined) updateData.published_date = body.publishedDate;
    if (body.description !== undefined) updateData.description = body.description;
    if (body.pageCount !== undefined) updateData.page_count = body.pageCount;
    if (body.categories !== undefined) updateData.categories = body.categories;
    if (body.averageRating !== undefined) updateData.average_rating = body.averageRating;
    if (body.ratingsCount !== undefined) updateData.ratings_count = body.ratingsCount;
    if (body.language !== undefined) updateData.language = body.language;
    if (body.infoLink !== undefined) updateData.info_link = body.infoLink;
    if (body.coverImage !== undefined) updateData.cover_image = body.coverImage;
    if (body.googleBooksId !== undefined) updateData.google_books_id = body.googleBooksId;
    if (body.enhancementStatus !== undefined) updateData.enhancement_status = body.enhancementStatus;
    if (body.enhancementDate !== undefined) updateData.enhancement_date = body.enhancementDate;
    if (body.enhancementError !== undefined) updateData.enhancement_error = body.enhancementError;

    // Update book in database
    const updatedDbBook = await BookDatabase.updateBook(body.id, updateData);
    
    if (!updatedDbBook) {
      const error: ApiError = {
        message: 'Failed to update book',
        code: 'BOOK_UPDATE_FAILED',
      };
      return NextResponse.json(error, { status: 500 });
    }

    // Convert and return updated book
    const updatedBook = convertDatabaseBookToBook(updatedDbBook);
    
    return NextResponse.json(updatedBook);

  } catch (error) {
    console.error('Error updating book:', error);
    
    const apiError: ApiError = {
      message: 'Internal server error while updating book',
      code: 'INTERNAL_SERVER_ERROR',
      details: error instanceof Error ? error.message : 'Unknown error',
    };
    
    return NextResponse.json(apiError, { status: 500 });
  }
}

export async function DELETE(request: NextRequest) {
  try {
    // Check if Supabase is configured
    if (!isSupabaseConfigured()) {
      const error: ApiError = {
        message: 'Database is not configured. Please set Supabase environment variables.',
        code: 'DATABASE_NOT_CONFIGURED',
      };
      return NextResponse.json(error, { status: 503 });
    }

    const url = new URL(request.url);
    const bookId = url.searchParams.get('id');
    
    if (!bookId) {
      const error: ApiError = {
        message: 'Missing required parameter: id',
        code: 'INVALID_REQUEST',
      };
      return NextResponse.json(error, { status: 400 });
    }

    // Check if book exists
    const existingBook = await BookDatabase.getBookById(bookId);
    if (!existingBook) {
      const error: ApiError = {
        message: 'Book not found',
        code: 'BOOK_NOT_FOUND',
      };
      return NextResponse.json(error, { status: 404 });
    }

    // Delete book from database
    const deleted = await BookDatabase.deleteBook(bookId);
    
    if (!deleted) {
      const error: ApiError = {
        message: 'Failed to delete book',
        code: 'BOOK_DELETION_FAILED',
      };
      return NextResponse.json(error, { status: 500 });
    }

    return NextResponse.json({ message: 'Book deleted successfully' });

  } catch (error) {
    console.error('Error deleting book:', error);
    
    const apiError: ApiError = {
      message: 'Internal server error while deleting book',
      code: 'INTERNAL_SERVER_ERROR',
      details: error instanceof Error ? error.message : 'Unknown error',
    };
    
    return NextResponse.json(apiError, { status: 500 });
  }
}